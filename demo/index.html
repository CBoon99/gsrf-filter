<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <!-- SEO -->
  <title>Zero Overshoot Demo — Bounded vs Unbounded Recursive Filtering Tool</title>
  <meta name="description" content="Interactive demo comparing bounded Zero Overshoot filtering vs EMA on synthetic signals. Evaluation only—no rights granted. Production use requires a commercial license. Patent-pending technology.">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://zeroovershoot.com/demo/">
  <link rel="icon" href="../favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="../style.css">
  
  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://zeroovershoot.com/demo/">
  <meta property="og:title" content="GSRF Demo — Bounded vs Unbounded Recursive Filtering Tool">
  <meta property="og:description" content="Compare bounded GSRF filtering vs EMA on synthetic signals. Adjust noise, target band, and parameters to see overshoot and crossings.">
  <meta property="og:site_name" content="GSRF">
  
  <!-- Twitter -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="GSRF Demo — Bounded vs Unbounded Filtering Tool">
  <meta name="twitter:description" content="Compare bounded GSRF filtering vs EMA on synthetic signals. Adjust noise, target band, and parameters to see overshoot and crossings.">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "headline": "GSRF Demo: bounded vs unbounded recursive filtering",
    "description": "Interactive demo comparing bounded GSRF filtering versus EMA on synthetic signals, highlighting overshoot and band-crossing metrics.",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://zeroovershoot.com/demo/"
    },
    "author": {
      "@type": "Organization",
      "name": "BoonMind",
      "url": "https://boonmind.io"
    },
    "publisher": {
      "@type": "Organization",
      "name": "BoonMind"
    }
  }
  </script>
  
  <style>
    /* Demo keeps its layout + component rules; base identity comes from ../style.css */
    :root { --good: #34d399; --warn: #fbbf24; --bad: #fb7185; --line: rgba(231,238,252,.14); --radius: 16px; }
    body { color: var(--text); }
    
    header {
      padding: 28px 18px 10px;
      max-width: 1120px;
      margin: 0 auto;
    }
    
    .title {
      display: flex;
      align-items: flex-end;
      gap: 14px;
      flex-wrap: wrap;
    }
    
    h1 {
      font-size: clamp(22px, 3vw, 34px);
      margin: 0;
      letter-spacing: .2px;
    }
    
    .badge {
      font-size: 12px;
      color: var(--muted);
      border: 1px solid rgba(125, 211, 252, .25);
      background: rgba(125, 211, 252, .08);
      padding: 6px 10px;
      border-radius: 999px;
    }
    
    .sub {
      margin: 10px 0 0;
      color: var(--muted);
      line-height: 1.5;
      max-width: 80ch;
      font-size: 14px;
    }
    
    .back-link {
      display: inline-block;
      margin-bottom: 16px;
      font-size: 13px;
      color: var(--accent);
      text-decoration: none;
    }
    
    .back-link:hover {
      text-decoration: underline;
    }
    
    main {
      max-width: 1120px;
      margin: 0 auto;
      padding: 18px;
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 16px;
    }
    
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.06) 0%, rgba(255,255,255,.02) 100%);
      border-radius: var(--radius);
      overflow: hidden;
    }
    
    .card .hd {
      padding: 14px 14px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: rgba(16, 26, 46, .55);
    }
    
    .card .hd h2 {
      margin: 0;
      font-size: 14px;
      letter-spacing: .3px;
      color: #dbe7ff;
    }
    
    .card .bd {
      padding: 14px;
    }
    
    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 12px 0 6px;
    }
    
    select,
    input[type="range"],
    input[type="number"] {
      width: 100%;
      padding: 10px;
      border-radius: 12px;
      background: rgba(15, 23, 42, .85);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--text);
      outline: none;
      font-size: 14px;
      -webkit-appearance: none;
    }
    
    input[type="range"] {
      padding: 0;
      height: 36px;
    }
    
    input[type="number"]:focus,
    select:focus {
      border-color: var(--accent);
    }
    
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .toggles {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }
    
    .chip {
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(15, 23, 42, .60);
      padding: 9px 10px;
      border-radius: 999px;
      cursor: pointer;
      user-select: none;
      font-size: 12px;
      color: #d6e3ff;
      transition: transform .05s ease, border-color .15s ease, background .15s ease;
    }
    
    .chip:hover {
      border-color: rgba(125, 211, 252, .30);
    }
    
    .chip:active {
      transform: translateY(1px);
    }
    
    .chip.active {
      border-color: rgba(125, 211, 252, .55);
      background: rgba(125, 211, 252, .10);
      box-shadow: 0 0 0 4px rgba(125, 211, 252, .06);
    }
    
    .btns {
      display: flex;
      gap: 10px;
      margin-top: 14px;
      flex-wrap: wrap;
    }
    
    /* Base button styles come from ../style.css; demo-specific tweaks only */
    button.secondary {
      background: rgba(15, 23, 42, .6);
      border: 1px solid rgba(255,255,255,.12);
      color: #dbe7ff;
    }
    
    .hint {
      margin-top: 12px;
      font-size: 12px;
      line-height: 1.5;
      color: var(--muted);
      border-top: 1px solid rgba(255,255,255,.08);
      padding-top: 12px;
    }
    
    .kpis {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 12px;
    }
    
    .kpi {
      padding: 10px;
      border-radius: 14px;
      background: rgba(15, 23, 42, .55);
      border: 1px solid rgba(255,255,255,.08);
    }
    
    .kpi .v {
      font-size: 16px;
      font-weight: 700;
    }
    
    .kpi .l {
      font-size: 11px;
      color: var(--muted);
      margin-top: 2px;
    }

    .industry-context{
      margin-bottom: 12px;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(15, 23, 42, .55);
    }
    .industry-context .ctx-title{
      font-size: 12px;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 10px;
    }
    .industry-context .ctx-grid{
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .industry-context .ctx-item{
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(15, 23, 42, .45);
      padding: 10px;
      border-radius: 14px;
    }
    .industry-context .ctx-k{
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .industry-context .ctx-v{
      font-size: 12px;
      line-height: 1.45;
      color: #dbe7ff;
    }
    .industry-context .ctx-ex{
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
    }
    .industry-context .ctx-note{
      margin-top: 8px;
      font-size: 11px;
      color: var(--muted);
      line-height: 1.45;
      opacity: .95;
    }
    .industry-context .ctx-note strong{ color: #dbe7ff; font-weight: 700; }
    @media (min-width: 980px){
      .industry-context .ctx-grid{ grid-template-columns: repeat(3, 1fr); }
    }
    
    .chart-container {
      position: relative;
      width: 100%;
      height: 420px;
    }
    
    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }
    
    .foot {
      max-width: 1120px;
      margin: 0 auto;
      padding: 0 18px 16px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.6;
    }
    
    footer {
      max-width: 1120px;
      margin: 0 auto;
      padding: 16px 18px 26px;
      border-top: 1px solid rgba(255,255,255,.08);
      text-align: center;
    }
    
    footer p {
      font-size: 12px;
      color: var(--muted);
      margin: 0;
      line-height: 1.6;
    }
    
    a {
      color: var(--accent);
    }
    
    code {
      background: rgba(255,255,255,.06);
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.08);
    }
    
    /* Tablet */
    @media (max-width: 980px) {
      main {
        grid-template-columns: 1fr;
      }
      
      .chart-container {
        height: 350px;
      }
    }
    
    /* Mobile */
    @media (max-width: 600px) {
      header {
        padding: 20px 16px 10px;
      }
      
      main {
        padding: 12px;
        gap: 12px;
      }
      
      .card .bd {
        padding: 12px;
      }
      
      .row {
        grid-template-columns: 1fr;
      }
      
      .chart-container {
        height: 280px;
      }
      
      .btns {
        flex-direction: column;
      }
      
      .btns button {
        width: 100%;
      }
      
      h1 {
        font-size: 22px;
      }
      
      .foot, footer {
        padding-left: 16px;
        padding-right: 16px;
      }
    }
  </style>
</head>
<body class="theme-dark">
  <a class="skip-link" href="#main">Skip to content</a>
  <header>
    <a href="../" class="back-link" id="backLink">← Back to GSRF</a>
    <button class="secondary" id="copyLinkBtn" type="button" style="margin-left: 10px;">Copy share link</button>
    <div class="title">
      <h1>GSRF Interactive Demonstration</h1>
    </div>
    <p class="sub">
      Bounded versus unbounded recursive filtering under identical inputs.
      This demonstration compares GSRF (bounded, zero-overshoot behaviour) against EMA on controlled synthetic signals.
    </p>
  </header>

  <main id="main">
    <section class="card" aria-label="How to read the demo">
      <div class="hd">
        <h2>How to read the demo</h2>
        <span class="badge">quick start</span>
      </div>
      <div class="bd">
        <ol style="margin: 0; padding-left: 18px; color: var(--muted); font-size: 13px; line-height: 1.6;">
          <li>Start with <strong>Step</strong> + <strong>EMA (α=0.50)</strong> to see overshoot.</li>
          <li>Switch to <strong>GSRF</strong> and compare how the output stays within the target band.</li>
          <li>Use <strong>Max overshoot</strong> and <strong>Band crossings</strong> as a quick boundedness read.</li>
        </ol>
        <p style="margin-top: 12px; margin-bottom: 0; color: var(--muted); font-size: 12px;">
          Synthetic, domain-shaped signals (not real-world data). Filter math is unchanged. Read overshoot, crossings, and time-to-stability to compare bounded vs unbounded behavior.
        </p>
        <p style="margin-top: 12px; margin-bottom: 0; color: var(--muted); font-size: 12px;">
          Learn more: <a href="../deterministic-safety-recursive-systems.html">deterministic safety</a>,
          <a href="../runaway-feedback-loop-prevention.html">runaway feedback</a>,
          <a href="../paper-gsrf-framework.html">paper abstracts</a>.
        </p>
      </div>
    </section>

    <section class="card" aria-label="Filter controls">
      <div class="hd">
        <h2>Controls</h2>
        <span class="badge" id="seedBadge">seed: 2026</span>
      </div>
      <div class="bd">
        <label for="industry">Industry preset</label>
        <select id="industry">
          <option value="">General (default)</option>
          <option value="autonomous">Autonomous control</option>
          <option value="robotics">Robotics</option>
          <option value="finance">Finance / Trading systems</option>
          <option value="industrial">Industrial control</option>
        </select>

        <label for="signalModel">Signal model</label>
        <select id="signalModel">
          <option value="industry">Industry-shaped (synthetic)</option>
          <option value="generic">Generic (synthetic)</option>
        </select>

        <label for="signalType">Signal type</label>
        <select id="signalType">
          <option value="step">Step</option>
          <option value="ramp">Ramp</option>
          <option value="sine">Noisy sine</option>
        </select>

        <label id="filterLabel">Filter</label>
        <div class="toggles" id="filterToggles" role="group" aria-labelledby="filterLabel">
          <div class="chip active" data-filter="gsrf" role="button" tabindex="0" aria-pressed="true">GSRF</div>
          <div class="chip" data-filter="ema_slow" role="button" tabindex="0" aria-pressed="false">EMA (α=0.10)</div>
          <div class="chip" data-filter="ema_fast" role="button" tabindex="0" aria-pressed="false">EMA (α=0.50)</div>
          <div class="chip" data-filter="all" role="button" tabindex="0" aria-pressed="false">Show all</div>
        </div>

        <div class="row">
          <div>
            <label for="noise">Noise (σ)</label>
            <input id="noise" type="range" min="0" max="1" step="0.01" value="0.15">
          </div>
          <div>
            <label for="noiseVal">σ value</label>
            <input id="noiseVal" type="number" min="0" max="1" step="0.01" value="0.15">
          </div>
        </div>

        <div class="row">
          <div>
            <label for="band">Target band (±)</label>
            <input id="band" type="number" min="0.01" max="2" step="0.01" value="0.15">
          </div>
          <div>
            <label for="target">Target center</label>
            <input id="target" type="number" min="-5" max="5" step="0.01" value="1.00">
          </div>
        </div>

        <label>GSRF parameters</label>
        <div class="row">
          <div>
            <label for="beta">β (0–1]</label>
            <input id="beta" type="number" min="0.01" max="1" step="0.01" value="0.30">
          </div>
          <div>
            <label for="kreturn">k_return (&gt;0)</label>
            <input id="kreturn" type="number" min="0.01" max="5" step="0.01" value="1.00">
          </div>
        </div>
        <div class="row">
          <div>
            <label for="mem">mem [0–0.5]</label>
            <input id="mem" type="number" min="0" max="0.5" step="0.01" value="0.20">
          </div>
          <div>
            <label for="baseline">b (|b|&lt;2)</label>
            <input id="baseline" type="number" min="-1.99" max="1.99" step="0.01" value="0.00">
          </div>
        </div>

        <div class="btns">
          <button id="regen">Regenerate</button>
          <button class="secondary" id="stepOnce">Step once</button>
          <button class="secondary" id="run">Run 300 steps</button>
        </div>

        <div class="kpis">
          <div class="kpi">
            <div class="v" id="kpiOvershoot">—</div>
            <div class="l">Max overshoot (selected)</div>
          </div>
          <div class="kpi">
            <div class="v" id="kpiCross">—</div>
            <div class="l">Band crossings (selected)</div>
          </div>
          <div class="kpi">
            <div class="v" id="kpiStable">—</div>
            <div class="l">Time to stability (steps)</div>
          </div>
        </div>

        <div class="hint">
          Tip: start with <code>Step</code> + <code>EMA (α=0.50)</code> to see overshoot, then switch to <code>GSRF</code>.
          "Show all" overlays all filters on the same signal.
        </div>
      </div>
    </section>

    <section class="card" aria-label="Signal visualization">
      <div class="hd">
        <h2>Signal + Filter Output</h2>
        <span class="badge" id="modeBadge">mode: gsrf</span>
      </div>
      <div class="bd">
        <div class="industry-context" aria-label="Industry context">
          <div class="ctx-title" id="ctxTitle">Industry context</div>
          <div class="ctx-grid">
            <div class="ctx-item">
              <div class="ctx-k">Typically optimizes</div>
              <div class="ctx-v" id="ctxOptimizes">—</div>
            </div>
            <div class="ctx-item">
              <div class="ctx-k">Common runaway failure pattern</div>
              <div class="ctx-v" id="ctxPattern">—</div>
            </div>
            <div class="ctx-item">
              <div class="ctx-k">What GSRF constrains</div>
              <div class="ctx-v" id="ctxConstrains">—</div>
            </div>
          </div>
          <div class="ctx-ex" id="ctxExamples">Examples: —</div>
          <div class="ctx-note" id="ctxModelNote">Signal model: — (synthetic)</div>
        </div>
        <div class="chart-container">
          <canvas id="chart"></canvas>
        </div>
      </div>
    </section>
  </main>

  <div class="foot">
    <p>
      Notes: Parameter envelopes are enforced in code. <a href="../">Return to GSRF overview</a>.
    </p>
  </div>
  
  <footer>
    <p style="margin-bottom: 8px;">
      © 2026 Carl Boon (BoonMind). Zero Overshoot is proprietary, patent-pending technology. Commercial use requires a license. Patent applications are in preparation.
      Contact: <a href="mailto:info@boonmind.io">info@boonmind.io</a>.
      <a href="../LICENSE">LICENSE</a> · <a href="../README.md">README</a>
    </p>
    <p style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,.08); font-size: 12px; color: var(--muted);">
      <strong>Demo Disclaimer:</strong> This demo is for evaluation only. No rights are granted by demo use. Production deployment requires a commercial license. Zero Overshoot is not open source. See <a href="../commercial-licensing-notes.html" style="color: var(--accent);">Commercial &amp; Licensing Notes</a> for details.
    </p>
    <p style="margin-top: 12px;">Built by <a href="https://boonmind.io" rel="noopener noreferrer">BoonMind</a>.<br>Research, safety frameworks, and system architecture.<br>For inquiries: <a href="mailto:info@boonmind.io">info@boonmind.io</a></p>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    // Utilities (seeded RNG)
    function mulberry32(seed) {
      let a = seed >>> 0;
      return function() {
        a |= 0;
        a = a + 0x6D2B79F5 | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }
    
    function randn(rng) {
      let u = 0, v = 0;
      while (u === 0) u = rng();
      while (v === 0) v = rng();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
    
    function clamp(x, lo, hi) {
      return Math.max(lo, Math.min(hi, x));
    }

    // Signal generators
    function generateSignalGeneric({ type, n, target, noiseSigma, rng }) {
      const y = new Array(n);
      for (let i = 0; i < n; i++) {
        let base = target;
        if (type === "step") {
          base = (i < 100) ? (target - 0.8) : (target + 0.8);
        } else if (type === "ramp") {
          base = (target - 0.7) + (1.4 * i / (n - 1));
        } else if (type === "sine") {
          const w = 2 * Math.PI * (i / 60);
          base = target + 0.55 * Math.sin(w);
        }
        y[i] = base + noiseSigma * randn(rng);
      }
      return y;
    }

    function sat(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }

    function generateSignalIndustryShaped({ industryKey, n, target, noiseSigma, rng }) {
      const y = new Array(n);
      const key = industryKey || "";

      // Synthetic, domain-shaped signal models (for intuition only).
      if (key === "autonomous") {
        // Step commands + actuator saturation + first-order lag + sensor noise
        const uMin = target - 1.2;
        const uMax = target + 1.2;
        const lag = 0.12;
        let x = target;
        for (let i = 0; i < n; i++) {
          const cmd = (i < 90) ? (target - 1.0) : (i < 180 ? (target + 1.0) : target);
          const u = sat(cmd, uMin, uMax);
          x = x + lag * (u - x);
          y[i] = x + noiseSigma * randn(rng);
        }
        return y;
      }

      if (key === "robotics") {
        // Oscillatory setpoint tracking + stiction + load changes
        let x = target;
        let load = 1.0;
        const lag = 0.10;
        const stiction = 0.02;
        for (let i = 0; i < n; i++) {
          if (i === 120) load = 1.25;
          if (i === 220) load = 0.90;
          const setpoint = target + 0.9 * Math.sin((2 * Math.PI * i) / 70);
          const err = (setpoint - x);
          const move = (Math.abs(err) < stiction) ? 0 : err;
          x = x + lag * (move / load);
          y[i] = x + noiseSigma * randn(rng);
        }
        return y;
      }

      if (key === "industrial") {
        // Setpoint steps + process dead time + slow drift
        const dead = 12;
        const tau = 0.06;
        let x = target;
        let drift = 0;
        const uHist = new Array(n).fill(target);
        for (let i = 0; i < n; i++) {
          const sp = (i < 110) ? (target - 0.7) : (i < 220 ? (target + 0.7) : target);
          uHist[i] = sp;
          const u = (i - dead >= 0) ? uHist[i - dead] : target;
          drift = 0.995 * drift + 0.003 * randn(rng);
          x = x + tau * ((u + 0.15 * drift) - x);
          y[i] = x + noiseSigma * randn(rng);
        }
        return y;
      }

      if (key === "finance") {
        // Regime shifts + volatility clustering + jumps + feedback amplification proxy
        let s = target;
        let sigma = Math.max(0.02, noiseSigma);
        let regime = 1.0;
        for (let i = 0; i < n; i++) {
          if (i === 90) regime = 1.6;
          if (i === 200) regime = 0.9;

          const z = randn(rng);
          const ret = regime * sigma * z;
          sigma = sat(0.92 * sigma + 0.10 * Math.abs(ret), 0.02, 0.35);

          const jump = (rng() < 0.02) ? (regime * (rng() < 0.5 ? -1 : 1) * (0.6 + 0.6 * rng())) : 0;
          const fb = 0.06 * (s - target);
          s = s + ret + jump + fb;
          y[i] = s;
        }
        return y;
      }

      return generateSignalGeneric({ type: "step", n, target, noiseSigma, rng });
    }

    // Filters
    function emaFilter(y, alpha) {
      const out = new Array(y.length);
      let s = y[0];
      out[0] = s;
      for (let i = 1; i < y.length; i++) {
        s = alpha * y[i] + (1 - alpha) * s;
        out[i] = s;
      }
      return out;
    }

    function gsrfFilter(y, params, rng) {
      const { target, beta, k_return, mem, baseline, delta } = params;
      const β = clamp(beta, 0.01, 1.0);
      const k = Math.max(0.01, k_return);
      const m = clamp(mem, 0.0, 0.5);
      const b = clamp(baseline, -1.99, 1.99);
      const δ = Math.max(0, delta);

      const minY = Math.min(...y);
      const shift = (minY <= 0) ? (1.0 - minY) : 0.0;

      const out = new Array(y.length);
      let x_star = Math.log(Math.max(target + shift, 1e-9));
      let x_prev = null;
      let x = x_star;

      for (let i = 0; i < y.length; i++) {
        const obs = Math.max(y[i] + shift, 1e-9);
        const x_obs = Math.log(obs);

        if (x_prev === null) x_prev = x_obs;

        const G = -(x - x_star);
        const R = Math.tanh(x - x_prev);
        const eta = (δ > 0) ? ((rng() * 2 - 1) * δ) : 0;

        const update = b + k * G + m * R;
        const x_new = x + β * update + eta;

        x_prev = x;
        x = x_new;
        out[i] = Math.exp(x) - shift;
      }
      return out;
    }

    // Metrics
    function calcMetrics(series, target, band) {
      let maxOvershoot = 0;
      let crossings = 0;
      let prevInside = null;
      for (let i = 0; i < series.length; i++) {
        const v = series[i];
        const overshoot = Math.max(0, Math.abs(v - target) - band);
        if (overshoot > maxOvershoot) maxOvershoot = overshoot;

        const inside = Math.abs(v - target) <= band;
        if (prevInside !== null && inside !== prevInside) crossings++;
        prevInside = inside;
      }
      return { maxOvershoot, crossings };
    }

    function timeToStability(series, target, band, windowLen = 20) {
      if (series.length < windowLen) return null;
      for (let i = 0; i <= series.length - windowLen; i++) {
        let ok = true;
        for (let j = 0; j < windowLen; j++) {
          if (Math.abs(series[i + j] - target) > band) { ok = false; break; }
        }
        if (ok) return i;
      }
      return null;
    }

    // UI + Chart
    const els = {
      industry: document.getElementById("industry"),
      signalModel: document.getElementById("signalModel"),
      signalType: document.getElementById("signalType"),
      noise: document.getElementById("noise"),
      noiseVal: document.getElementById("noiseVal"),
      band: document.getElementById("band"),
      target: document.getElementById("target"),
      beta: document.getElementById("beta"),
      kreturn: document.getElementById("kreturn"),
      mem: document.getElementById("mem"),
      baseline: document.getElementById("baseline"),
      regen: document.getElementById("regen"),
      stepOnce: document.getElementById("stepOnce"),
      run: document.getElementById("run"),
      kpiOvershoot: document.getElementById("kpiOvershoot"),
      kpiCross: document.getElementById("kpiCross"),
      kpiStable: document.getElementById("kpiStable"),
      filterToggles: document.getElementById("filterToggles"),
      modeBadge: document.getElementById("modeBadge"),
      seedBadge: document.getElementById("seedBadge"),
    };

    const ctxEls = {
      backLink: document.getElementById("backLink"),
      title: document.getElementById("ctxTitle"),
      optimizes: document.getElementById("ctxOptimizes"),
      pattern: document.getElementById("ctxPattern"),
      constrains: document.getElementById("ctxConstrains"),
      examples: document.getElementById("ctxExamples"),
      modelNote: document.getElementById("ctxModelNote"),
    };

    const INDUSTRIES = {
      "": {
        key: "",
        name: "General (default)",
        axis: { x: "Time step", y: "Signal value (normalized)" },
        defaults: { signalType: "step", target: 1.0, band: 0.15, noise: 0.15, beta: 0.30, kreturn: 1.00, mem: 0.20, baseline: 0.00, mode: "gsrf" },
        context: {
          title: "Industry context",
          optimizes: "Stability and boundedness under recursion",
          pattern: "Amplified error and overshoot under feedback",
          constrains: "Update magnitude within a configured envelope",
          examples: "Examples: band ±0.15, σ=0.15 (example)"
        }
      },
      autonomous: {
        key: "autonomous",
        name: "Autonomous control",
        axis: { x: "Time (steps)", y: "Tracking error (deg, example)" },
        defaults: { signalType: "step", target: 0.0, band: 0.6, noise: 0.10, beta: 0.28, kreturn: 1.20, mem: 0.18, baseline: 0.00, mode: "gsrf" },
        context: {
          title: "Industry context: autonomous control",
          optimizes: "Tracking error, settling time, and actuator smoothness",
          pattern: "Overshoot/oscillation after step changes; unstable correction loops",
          constrains: "Update step size so response stays within the target band",
          examples: "Examples: target 0.0° ±0.6°, σ=0.10; 0.18s settling (example)"
        }
      },
      robotics: {
        key: "robotics",
        name: "Robotics",
        axis: { x: "Time (steps)", y: "Command deviation (%, example)" },
        defaults: { signalType: "ramp", target: 0.0, band: 12.0, noise: 0.12, beta: 0.26, kreturn: 1.10, mem: 0.22, baseline: 0.00, mode: "gsrf" },
        context: {
          title: "Industry context: robotics",
          optimizes: "Task success, smooth motion, and constraint compliance",
          pattern: "Adaptive drift and unstable corrections under feedback",
          constrains: "Per-step change so commands stay within a safe envelope",
          examples: "Examples: band ±12%, σ=0.12; 35-step stability window (example)"
        }
      },
      finance: {
        key: "finance",
        name: "Finance / Trading systems",
        axis: { x: "Time (steps)", y: "Signal / exposure (normalized, example)" },
        defaults: { signalType: "sine", target: 1.0, band: 0.25, noise: 0.25, beta: 0.22, kreturn: 0.95, mem: 0.25, baseline: 0.05, mode: "ema_fast" },
        context: {
          title: "Industry context: finance / trading",
          optimizes: "Return vs risk (volatility, drawdown) under iterative updates",
          pattern: "Signal chasing and amplified exposure changes across iterations",
          constrains: "Update magnitude and momentum so the loop stays bounded",
          examples: "Examples: σ=0.25, band ±0.25; 2.5× peak amplitude (example)"
        }
      },
      industrial: {
        key: "industrial",
        name: "Industrial control",
        axis: { x: "Time (steps)", y: "Process variable (%, example)" },
        defaults: { signalType: "step", target: 1.0, band: 3.0, noise: 0.06, beta: 0.30, kreturn: 1.05, mem: 0.16, baseline: 0.00, mode: "gsrf" },
        context: {
          title: "Industry context: industrial control",
          optimizes: "Stability, constraint compliance, and recovery after disturbances",
          pattern: "Slow drift, saturation, and delayed divergence in feedback loops",
          constrains: "Bounded response within a configured tolerance band",
          examples: "Examples: band ±3.0%, σ=0.06; 0.9s settling (example)"
        }
      }
    };

    let seed = 2026;
    els.seedBadge.textContent = "seed: " + seed;

    let userLockedSignalModel = false;

    // Initialize mode to match the active chip (gsrf)
    let mode = "gsrf";
    
    function setMode(newMode) {
      mode = newMode;
      [...els.filterToggles.querySelectorAll(".chip")].forEach(ch => {
        const isActive = ch.dataset.filter === newMode;
        ch.classList.toggle("active", isActive);
        ch.setAttribute("aria-pressed", isActive);
      });
      els.modeBadge.textContent = "mode: " + (mode === "all" ? "show all" : mode);
      render();
    }

    function applyIndustryPreset(key, opts = { pushState: true }) {
      const preset = INDUSTRIES[key] || INDUSTRIES[""];
      els.industry.value = preset.key;

      if (!userLockedSignalModel) {
        els.signalModel.value = preset.key ? "industry" : "generic";
      }

      els.signalType.value = preset.defaults.signalType;
      els.target.value = String(preset.defaults.target);
      els.band.value = String(preset.defaults.band);
      els.noise.value = String(preset.defaults.noise);
      els.noiseVal.value = String(preset.defaults.noise);
      els.beta.value = String(preset.defaults.beta);
      els.kreturn.value = String(preset.defaults.kreturn);
      els.mem.value = String(preset.defaults.mem);
      els.baseline.value = String(preset.defaults.baseline);

      if (ctxEls.title) ctxEls.title.textContent = preset.context.title;
      if (ctxEls.optimizes) ctxEls.optimizes.textContent = preset.context.optimizes;
      if (ctxEls.pattern) ctxEls.pattern.textContent = preset.context.pattern;
      if (ctxEls.constrains) ctxEls.constrains.textContent = preset.context.constrains;
      if (ctxEls.examples) ctxEls.examples.textContent = preset.context.examples;
      if (ctxEls.modelNote) {
        const m = (els.signalModel.value || "generic") === "industry" ? "Industry-shaped" : "Generic";
        ctxEls.modelNote.innerHTML = 'Signal model: <strong>' + m + '</strong> (synthetic)';
      }

      if (ctxEls.backLink) {
        ctxEls.backLink.href = preset.key ? ("../?industry=" + encodeURIComponent(preset.key)) : "../";
      }

      // Axis labels (Chart.js)
      chart.options.scales.x.title = { display: true, text: preset.axis.x, color: "#cfe0ff", font: { size: 12, weight: "600" } };
      chart.options.scales.y.title = { display: true, text: preset.axis.y, color: "#cfe0ff", font: { size: 12, weight: "600" } };

      if (opts && opts.pushState) {
        try {
          const url = new URL(window.location.href);
          if (preset.key) url.searchParams.set("industry", preset.key);
          else url.searchParams.delete("industry");
          // Persist signal model so share links are stable
          const model = (els.signalModel.value || "generic").trim().toLowerCase();
          url.searchParams.set("signalModel", model === "industry" ? "industry" : "generic");
          window.history.replaceState({}, "", url.toString());
        } catch (_) {}
      }

      setMode(preset.defaults.mode);
    }

    els.filterToggles.addEventListener("click", (e) => {
      const chip = e.target.closest(".chip");
      if (!chip) return;
      setMode(chip.dataset.filter);
    });
    
    // Keyboard support for chips
    els.filterToggles.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        const chip = e.target.closest(".chip");
        if (chip) {
          e.preventDefault();
          setMode(chip.dataset.filter);
        }
      }
    });

    function syncNoise(from) {
      if (from === "range") els.noiseVal.value = els.noise.value;
      if (from === "num") els.noise.value = els.noiseVal.value;
      render();
    }
    
    els.noise.addEventListener("input", () => syncNoise("range"));
    els.noiseVal.addEventListener("input", () => syncNoise("num"));

    ["signalType", "band", "target", "beta", "kreturn", "mem", "baseline"].forEach(id => {
      els[id].addEventListener("input", render);
    });

    els.regen.addEventListener("click", () => {
      seed = (seed + 1) >>> 0;
      els.seedBadge.textContent = "seed: " + seed;
      render();
    });

    const ctx = document.getElementById("chart");
    const chart = new Chart(ctx, {
      type: "line",
      data: { labels: [], datasets: [] },
      options: {
        animation: false,
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: "index", intersect: false },
        plugins: {
          legend: { labels: { color: "#cfe0ff" } },
          tooltip: { enabled: true }
        },
        scales: {
          x: { ticks: { color: "#9fb1d1" }, grid: { color: "rgba(255,255,255,.06)" } },
          y: { ticks: { color: "#9fb1d1" }, grid: { color: "rgba(255,255,255,.06)" } }
        },
        elements: {
          point: { radius: 0 },
          line: { tension: 0.15, borderWidth: 2 }
        }
      }
    });

    let N = 300;
    
    function computeAll() {
      const rng = mulberry32(seed);
      const type = els.signalType.value;
      const target = parseFloat(els.target.value);
      const band = parseFloat(els.band.value);
      const noiseSigma = parseFloat(els.noise.value);

      const industryKey = (els.industry.value || "").trim().toLowerCase();
      const model = (els.signalModel.value || "generic").trim().toLowerCase();
      const y = (model === "industry")
        ? generateSignalIndustryShaped({ industryKey, n: N, target, noiseSigma, rng })
        : generateSignalGeneric({ type, n: N, target, noiseSigma, rng });
      const emaSlow = emaFilter(y, 0.10);
      const emaFast = emaFilter(y, 0.50);

      const gsrfParams = {
        target,
        beta: parseFloat(els.beta.value),
        k_return: parseFloat(els.kreturn.value),
        mem: parseFloat(els.mem.value),
        baseline: parseFloat(els.baseline.value),
        delta: 0.0
      };

      const rng2 = mulberry32(seed ^ 0xA5A5A5A5);
      const gsrf = gsrfFilter(y, gsrfParams, rng2);

      return { y, emaSlow, emaFast, gsrf, target, band };
    }

    function render() {
      const { y, emaSlow, emaFast, gsrf, target, band } = computeAll();
      const labels = Array.from({ length: y.length }, (_, i) => i);

      const bandTop = y.map(() => target + band);
      const bandBot = y.map(() => target - band);
      const targetLine = y.map(() => target);

      const datasets = [];

      datasets.push({
        label: "Raw (synthetic)",
        data: y,
        borderColor: "rgba(231,238,252,.55)",
        borderWidth: 1.5
      });

      datasets.push({
        label: "Target",
        data: targetLine,
        borderColor: "rgba(52,211,153,.55)",
        borderDash: [6, 6],
        borderWidth: 2
      });
      
      datasets.push({
        label: "Band +",
        data: bandTop,
        borderColor: "rgba(251,191,36,.35)",
        borderDash: [4, 6],
        borderWidth: 1.5
      });
      
      datasets.push({
        label: "Band -",
        data: bandBot,
        borderColor: "rgba(251,191,36,.35)",
        borderDash: [4, 6],
        borderWidth: 1.5
      });

      const show = (m) => mode === "all" || mode === m;

      if (show("gsrf")) {
        datasets.push({
          label: "GSRF",
          data: gsrf,
          borderColor: "rgba(125,211,252,.95)",
          borderWidth: 2.5
        });
      }
      
      if (show("ema_slow")) {
        datasets.push({
          label: "EMA α=0.10",
          data: emaSlow,
          borderColor: "rgba(167,139,250,.85)",
          borderWidth: 2
        });
      }
      
      if (show("ema_fast")) {
        datasets.push({
          label: "EMA α=0.50",
          data: emaFast,
          borderColor: "rgba(251,113,133,.85)",
          borderWidth: 2
        });
      }

      chart.data.labels = labels;
      chart.data.datasets = datasets;
      chart.update();

      let selectedSeries = gsrf;
      if (mode === "ema_slow") selectedSeries = emaSlow;
      if (mode === "ema_fast") selectedSeries = emaFast;
      if (mode === "all") selectedSeries = gsrf;

      const m = calcMetrics(selectedSeries, target, band);
      els.kpiOvershoot.textContent = m.maxOvershoot.toFixed(3);
      els.kpiCross.textContent = String(m.crossings);

      const tts = timeToStability(selectedSeries, target, band, 20);
      els.kpiStable.textContent = (tts === null) ? "—" : String(tts);
    }

    els.stepOnce.addEventListener("click", render);
    els.run.addEventListener("click", render);

    els.signalModel.addEventListener("input", () => {
      userLockedSignalModel = true;
      if (ctxEls.modelNote) {
        const m = (els.signalModel.value || "generic") === "industry" ? "Industry-shaped" : "Generic";
        ctxEls.modelNote.innerHTML = 'Signal model: <strong>' + m + '</strong> (synthetic)';
      }
      // Keep URL in sync when user changes model
      try {
        const url = new URL(window.location.href);
        const model = (els.signalModel.value || "generic").trim().toLowerCase();
        url.searchParams.set("signalModel", model === "industry" ? "industry" : "generic");
        window.history.replaceState({}, "", url.toString());
      } catch (_) {}
      render();
    });

    // Init industry preset from URL
    (function initIndustry() {
      let key = "";
      try {
        const params = new URLSearchParams(window.location.search);
        key = (params.get("industry") || "").trim().toLowerCase();
      } catch (_) {}
      if (!Object.prototype.hasOwnProperty.call(INDUSTRIES, key)) key = "";
      applyIndustryPreset(key, { pushState: false });
    })();

    els.industry.addEventListener("input", () => applyIndustryPreset(els.industry.value, { pushState: true }));

    // Initialize / persist signalModel from URL if present
    (function initSignalModel() {
      try {
        const params = new URLSearchParams(window.location.search);
        const sm = (params.get("signalModel") || "").trim().toLowerCase();
        if (sm === "industry" || sm === "generic") {
          userLockedSignalModel = true;
          els.signalModel.value = sm;
          if (ctxEls.modelNote) {
            const m = sm === "industry" ? "Industry-shaped" : "Generic";
            ctxEls.modelNote.innerHTML = 'Signal model: <strong>' + m + '</strong> (synthetic)';
          }
        }
      } catch (_) {}
    })();

    // Copy share link (clipboard with fallback)
    (function initCopyLink() {
      const btn = document.getElementById("copyLinkBtn");
      if (!btn) return;
      btn.addEventListener("click", async () => {
        const link = window.location.href;
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(link);
            const old = btn.textContent;
            btn.textContent = "Copied";
            setTimeout(() => { btn.textContent = old; }, 1200);
          } else {
            window.prompt("Copy this link:", link);
          }
        } catch (_) {
          window.prompt("Copy this link:", link);
        }
      });
    })();

    // Initial render
    render();
  </script>
</body>
</html>
